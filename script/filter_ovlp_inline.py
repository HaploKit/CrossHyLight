import sys
from itertools import islice

__author__ = "Xiao Luo"

usage = '''
This program is used to filter long read overlaps(i.e.,duplicate or internal overlaps)
which are generated by minimap2
'''


def rm_dupovlp(ovlp_str):
    '''
    only keep the longest overlap if multiple overlaps exist for one pair reads
    and remove self-overlaps
    '''
    ovlp = {}
    self_counts = 0
    dup_counts = 0
    for line in ovlp_str.strip().split('\n'):
        if not line:
            continue
        a = line.strip().split()
        qname = a[0]
        tname = a[5]
        if qname == tname:
            self_counts += 1
            continue
        ovlp_len = int(a[10])
        key = ':'.join(sorted([qname, tname]))
        if key not in ovlp:
            ovlp[key] = line
        elif ovlp_len > int(ovlp[key].split()[10]):
            ovlp[key] = line
            dup_counts += 1

    ovlp_str2 = '\n'.join([ovlp[key] for key in ovlp.keys()])
    ovlp = {}
    return ovlp_str2


def rm_intermatch(ovlp_str, min_ovlp_len, min_identity, o=1000, r=0.8):
    '''
    filter internal match overlaps
    o: overhang length
    r: ratio
    '''
    ovlps = []
    inter = 0
    for line in ovlp_str.strip().split('\n'):
        a = line.strip().split()
        l1 = int(a[1])
        b1 = int(a[2])
        e1 = int(a[3])
        direction = a[4]
        l2 = int(a[6])

        if (int(a[10]) < min_ovlp_len) or (float(a[9]) / float(a[10]) < min_identity):
            continue

        if direction == '-':
            '''
            - overhang region: ***
            - b2,e2: both are the cordinates in the following sequence,
              no matter what the direction is.

                       b1        e1    l1
            v ------------------------->
                   |***|/////////|*****|
                w  <----------------------------
                       b2        e2            l2
            '''
            b2 = l2 - int(a[8])  # end in original seq
            e2 = l2 - int(a[7])  # start in original seq
        else:
            b2 = int(a[7])
            e2 = int(a[8])

        # from algorithm 5 in minimap paper
        overhang = min(b1, b2) + min(l1 - e1, l2 - e2)
        maplen = max(e1 - b1, e2 - b2)

        if overhang > min(o, maplen * r):
            # internal match
            inter += 1
            continue
        else:
            ovlps.append(line)
    ovlp_str2 = '\n'.join(ovlps)
    del ovlps
    return ovlp_str2


def filter_ovlp(min_ovlp_len, min_identity, o, r):
    if not sys.stdin.isatty():
        while True:
            ovlp_item = list(islice(sys.stdin, 1000))
            if not ovlp_item:
                break
            ovlp_str = ''.join(ovlp_item).strip()

            ovlp_str = rm_intermatch(ovlp_str, min_ovlp_len, min_identity, o, r)
            ovlp_str = rm_dupovlp(ovlp_str)
            if ovlp_str:
                print(ovlp_str)
    return


if __name__ == '__main__':
    min_ovlp_len, min_identity, o, r = sys.argv[1:]
    filter_ovlp(int(min_ovlp_len), float(min_identity), int(o), float(r))

