#!/usr/bin/env python

import sys
from argparse import ArgumentParser
from collections import defaultdict
from itertools import islice

__author__ = "Xiongbin Kang, Luo Xiao"


usage = """%prog <min_ovlp_len> <min_iden> <mini overhang>

 This program is used to filter read overlaps(i.e.,duplicate or internal overlaps) in paf file that were generated by mininmap2
 
"""

def main():
    parser = ArgumentParser(description = usage)
    parser.add_argument('-len', dest = 'min_ovlp_len', default = 500, type = int)
    parser.add_argument('-iden', dest = 'min_iden', default = 0.9, type = float)
    parser.add_argument('-oh', dest = 'min_o', default = 0, type = int)
    parser.add_argument('-ovlpn', dest = 'ovlpn', default = 1000, type = int)
    parser.add_argument('-sfo', dest = 'sfo', action='store_true')
    parser.add_argument('-filter', dest = 'filter', action='store_true')
    args = parser.parse_args()

    if not (args.min_ovlp_len and args.min_iden):
        print("Specify min over length and min identical.")
        parser.print_help()
        sys.exit()

    nu = defaultdict(int)
    
    if not sys.stdin.isatty():
      while True:
        ovlp_item = list(islice(sys.stdin, 1000))
        if not ovlp_item:
            break
        ovlp_str = ''.join(ovlp_item).strip()

        d = defaultdict(list)
        
        for line in ovlp_str.strip().split('\n'):
            
            len_t = line.split('\t')
            if len(len_t) < 12:
                continue

            [qseqid, qlen, qstart, qend, qori, sseqid, slen, sstart, send, matchcount, length] = line.split('\t')[:11]
            
            (qlen, qstart, qend, slen, sstart, send, matchcount, length) = map(int, [qlen, qstart, qend, slen, sstart, send, matchcount, length])
            
            mlen=(qlen+slen)/2
            
#            if (qlen - (qend - qstart) < 50 ) or (slen - (send - sstart) < 50 ):
#                continue
            
            if nu[qseqid] > args.ovlpn or nu[sseqid] > args.ovlpn:
                continue

            if (length < args.min_ovlp_len) or (matchcount / length < args.min_iden) or (qseqid == sseqid):
                continue
            
            key1 = ':'.join(sorted([qseqid, sseqid]))
            if key1 in d:
                continue    
            d[key1] = 1
            
            # filter overlap with overhang parameter
            if qori == '-':
                sstart2 = slen - send  # end in original seq
                send2 = slen - sstart  # start in original seq
            
                overhang = min(qstart, sstart2) + min(qlen - qend, slen - send2)
                maplen = max(qend - qstart, send2 - sstart2)

            else:
                # from algorithm 5 in minimap paper
                overhang = min(qstart, sstart) + min(qlen - qend, slen - send)
                maplen = max(qend - qstart, send - sstart)

            if overhang > min(args.min_o, maplen * 0.8):
                # internal match
                continue
            
            nu[qseqid] += 1 
            nu[sseqid] += 1
            
            # tranfer the format of minimap2 to sfo
            score = format((0.4*(length/mlen)+0.6*(matchcount/length)), '.4f')
            if args.sfo:
                line = minimap22sfo(qseqid, qlen, qstart, qend, qori, sseqid, slen, sstart, send, matchcount, length)
                print(line)
            elif args.filter:
               filter_list(qseqid, qlen, qstart, qend, qori, sseqid, slen, sstart, send, score)

            else:
                (qlen, qstart, qend, slen, sstart, send, matchcount1, length1) = map(str, [qlen, qstart, qend, slen, sstart, send, matchcount, length])
                line2 ="\t".join([qseqid, qlen, qstart, qend, qori, sseqid, slen, sstart, send, matchcount1, length1, str(score)])
                print(line2)
#        print(nu)
    
def filter_list(qseqid, qlen, qstart, qend, qori, sseqid, slen, sstart, send, score):

              if((float(score) > 0.8) and (qlen == qend or slen == send)):
                if(qlen > slen):
                    print(score, qseqid)
                else:
                    print(score, sseqid)
			  
    
def minimap22sfo(qseqid, qlen, qstart, qend, qori, sseqid, slen, sstart, send, matchcount, length):
            ori = 'N' if qori == '+' else 'I'
            
            if ori == 'N':
                OHA = qstart - sstart
                OHB = slen - sstart - (qlen - qstart)
            else:
                OHA = qstart - (slen - send)
                OHB = send - (qlen - qstart)
                
            if OHA >= 0:
                OLA = min(qlen - OHA, slen)
            else:
                OLA = min(slen + OHA, qlen)
                
            OLB = OLA
            mismatch = length - matchcount
            
            sfo_line = '\t'.join([qseqid, sseqid, ori, str(OHA), str(OHB), str(OLA), str(OLB), str(mismatch)])
            return sfo_line
            

if __name__ == '__main__':
        sys.exit(main())
